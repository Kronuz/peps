PEP: 9999
Title: Lazy Imports
Author: Germán Méndez Bravo
Sponsor:
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 29-Apr-2022

Abstract
========

This PEP proposes a feature to make defer the load and execution of imported
objects, providing a robust solution to the often used paradigm of making
things lazy in Python. Making imports lazy, besides reducing the number of
loaded modules at run time improving startup (and even overall execution)
speed, also has the pretty great side effect of reducing the risk of hitting
circular imports.

Motivation
==========

Tightly coupled design or highly entwined modules, make hard to stop the
"Import Domino Effect" when importing anything in a codebase; this is something
we frequently see in big and complex codebases that have evolved over time,
where many of the imported modules over the files are only imported at module
level for readability, maintainability and/or simplicity. The unfortunate
result of this kind of state is that an increasing number of loaded modules
during startup can significantly increase the time a system needs to start up,
and some times we are spending a large amount of time loading modules that may
or may not be used during the execution of the system.

In the past, experience has shown us that trying to manually solve these
problems by making things lazy (using inner imports or carefully tailoring
solutions to lazify expensive subsystems) leads to easily breakable and hard to
maintain efforts. What’s more, in attempts to solve these problems or improve
design, refactoring of these highly evolved and highly entwined systems is
difficult because even changes in imports order can lead to hard to debug and
difficult to solve import cycles.

Rationale and Goals
===================

Fast iteration cycle is one of the reasons that Python is loved by developers.
However, in large and complex codebases, we’ve found that Python encounters a
serious usability problem, where just starting an application may take a long
time (minutes in some cases!), due to spending a lot of time executing imports
and module-level code at import time.

The goal of this PEP is to provide a feature for deferring loading and
executing of imported modules from the time of import to the time of first use
which:

* provides a mostly transparent and robust mechanism to achieve lazy
  importing of modules;

* implements an option flag to enable to mechanism, with minimal risk of
  breaking backwards compatibility;

* helps reducing the likelihood of bumping into import cycles when refactoring
  codebases; and,

* has none or negligible performance impact on the existing code or the code
  that will be using the new mechanism.

Specification
=============

The mechanism for enabling Lazy Imports is optional and can be globally enabled
by passing a flag (``-X lazyimportsall``) to the python runtime.

When enabled, the loading and execution of all (and only) top level import
modules shall be deferred until the imported name is used; this could happen
immediately, i.e. in the very next line after the import statement, or much
later, e.g. while using the name inside a function being calling by some other
code at some later time.

For these top level import modules, there are two exceptions which will make
them eager (not deferred): modules inside ``try``/``except``/``finally``
blocks; and star imports.

All other imports throughout the modules remain eager.

Backwards Compatibility
=======================

This proposal preserves 100% backwards compatibility when the feature is
disabled.

When enabled, the mechanics of the import system is modified in a way
such that deferred imports could produce currently unexpected results and
behaviors in existing codebases. The problems that are expected to be more
common when we enabling Lazy Imports mechanism are related to:

Import Side Effects
-------------------

Those using this feature should be aware that import side effects that are
otherwise usually produced by the execution of imported modules during the
execution of import statements could and will be deferred at least until the
imported objects are used and even indefinitely delayed for modules imported
inside imported modules.

These import side effects may include:

* code executing any logic when being imported;
* relying on submodules being set as attributes in the parent modules.

Dynamic Paths
-------------

There could be issues related to dynamic Python paths; particularly, adding
(and then removing after the import) paths from ``sys.path``.

.. code-block py
    sys.path.insert(0, "/path/to/foo/module")
    import foo
    del sys.path[0]
    foo.Bar()

Deferred Errors
---------------

All the errors are deferred from import time to first-use time (including
``ModuleNotFoundError``), which might complicate debugging. Accessing an object
in the middle of an statement could trigger an import and produce `ImportError`
or any number of other exceptions resulting from the resolution of the deferred
object, while loading and executing the related imported module.

Security Implications
=====================

Deferred execution of code could produce security concerns if process owner,
path, ``sys.path``, or other sensitive environment or contextual states change
between the time the ``import`` statement is executed and the time where the
imported object is used.

Performance Impact
==================

The reference implementation has shown that the feature alone has negligible
performance impact on the existing code or the code that will be using the new
mechanism, including C extensions. Some times we can see a degraded performance
under certain circumstances, but some times also improved performance as well,
due to the reduced number of modules needed to be loaded.

How to Teach This
=================

Some best practices to deal with some of the issues that could arise and to
better take advantage of Lazy Imports are:

* Avoid relying in import side effects. Often times used for the Registry
  Pattern, where systems expect registration happens implicitly during the
  importing of modules. Registration should have to be refactored for be
  explicitly called, triggering a discovery process, if needed.

* Always import each module being used, don't rely on module objects having
  attributes to child submodules; i.e.: do ``import foo.bar; foo.bar.Baz``,
  not ``import foo; foo.bar.Baz``. The latter only works (unreliably) because
  the attribute bar in the module ``foo`` is added as an import side effect of
  ``foo.bar`` being imported somewhere else. With Lazy Imports this may not
  always happen on time.

* Avoid using star imports, as those are always eager.

* When possible, do not import whole submodules. Import specific names instead;
  i.e.: do ``from foo.bar import Baz``, not ``import foo.bar`` and then
  ``foo.bar.Baz``. If you import submodules (such as ``foo.qux`` and
  ``foo.fred``), with Lazy Imports enabled, when you access the parent module's
  name (``foo`` in this case), that will trigger loading all of the sibling
  submodules of the parent module (``foo.bar``, ``foo.qux`` and ``foo.fred``),
  not only the one being accessed, because the parent module ``foo`` is the
  actual deferred object name.

* Don't use inner imports, unless absolutely necessary. Circular imports should
  no longer be a big issue with Lazy Imports enabled, so there’s no need to add
  complexity or more opcodes in a potentially hot path.

* Always use ``from __future__ import annotations`` when possible. This way,
  modules that are imported only for typing purposes will never be loaded under
  Lazy Imports.

* Use string type annotations for ``typing.TypeVar()`` and ``typing.NewType()``.
  The reason is Python doesn't have postponed evaluation of types being used in
  these helper classes.

* Wrap type aliases inside a ``TYPE_CHECKING`` conditional block (only type
  aliases, there is no particular need to do type-only imports inside this
  block). The reason is Python doesn't support postponed evaluation of types
  for type aliases.

Reference Implementation
========================

The current reference implementation is available as part of Cinder [1]_ as a
runtime-level feature that provides a transparent and robust mechanism for lazy
loading imports. Reference implementation is in use within Meta Platforms and
has proven to achieve improvements in startup time (and total runtime for some
applications) in the range of 40%-70%, as well as significant reduction in
memory footprint (up to 40%), thanks to not needing to resolve some of the
deferred imports that end up being unused in the common flow.

References
==========

.. [1] Reference implementation
   (https://github.com/facebookincubator/cinder)

Copyright
=========

This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.
